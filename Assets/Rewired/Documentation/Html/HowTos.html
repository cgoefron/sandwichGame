<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!-- InstanceBegin template="/Templates/BasicTemplate.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- InstanceBeginEditable name="doctitle" -->
<title>Rewired Documentation | How To's</title>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="head" -->
<!-- InstanceEndEditable -->
<!-- InstanceParam name="isRoot" type="boolean" value="false" -->
<link href="files/css/styles.css" rel="stylesheet" type="text/css" />
<!-- Favicons -->
<link rel="icon" type="image/x-icon" href="/projects/rewired/files/images/favicon.ico?v=1" />
<!-- Apple Icons -->
<!-- For iPad with high-resolution Retina display running iOS = 7: -->
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="files/images/favicon_152x152.png?v=1">
<!-- For iPad with high-resolution Retina display running iOS = 6: -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="files/images/favicon_144x144.png?v=1">
<!-- For iPhone with high-resolution Retina display running iOS = 7: -->
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="files/images/favicon_120x120.png?v=1">
<!-- For iPhone with high-resolution Retina display running iOS = 6: -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="files/images/favicon_114x114.png?v=1">
<!-- For the iPad mini and the first- and second-generation iPad on iOS = 7: -->
<link rel="apple-touch-icon-precomposed" sizes="76x76" href="files/images/favicon_76x76.png?v=1">
<!-- For the iPad mini and the first- and second-generation iPad on iOS = 6: -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="files/images/favicon_72x72.png?v=1">
<!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: -->
<link rel="apple-touch-icon-precomposed" href="files/images/favicon_57x57.png?v=1">
</head>

<body>

<div class="container">
  <div class="content">
	
	
	 
    <div class="page-body">
	
    
         
	    
      	<div class="sidebar-nav">
	        <h4><a href="Documentation.html">Documentation</a></h4>

            <strong>The Essentials:</strong>
            <ol>
              <li><a href="Overview.html">Overview</a></li>
              <li><a href="Installation.html">Installation</a></li>
              <li><a href="QuickStart.html">Quick Start</a></li>
              <li><a href="BasicUsage.html">Basic Usage</a></li>
              <li><a href="Deployment.html">Deployment</a></li>
              <li><a href="RewiredEditor.html">Rewired Editor</a></li>
              <li><a href="http://guavaman.com/projects/rewired/docs/api-reference" target="_blank">API Reference</a></li>
            </ol>
            <strong>Concepts:</strong>
            <ul>
              <li><a href="InputManager.html">Input Manager</a></li>
              <li><a href="Players.html">Players</a></li>
              <li><a href="Actions.html">Actions</a></li>
              <li><a href="InputBehaviors.html">Input Behaviors</a></li>
              <li><a href="Controllers.html">Controllers</a></li>
              <li><a href="ControllerMaps.html">Controller Maps</a></li>
              <li><a href="MapCategories.html">Map Categories</a></li>
              <li><a href="ControllerMaps.html"></a><a href="Layouts.html">Layouts</a></li>
              <li><a href="CustomControllers.html">Custom Controllers</a></li>
            </ul>
            <strong>How To's</strong>
            <ul>
            	<li><a href="HowTos.html">See all topics...</a></li>
            </ul>
            <strong>Extras:</strong>
            <ul>
              <li><a href="UserDataStore.html" title="User Data Store">User Data Store</a></li>
              <li><a href="ControlMapper.html" title="Control Mapper">Control Mapper</a></li>
              <li><a href="RewiredStandaloneInputModule.html">Rewired Standalone Input Module</a></li>
            </ul>
            <strong>Help:</strong>
            <ul>
              <li><a href="SupportedControllers.html" title="Supported Controllers">Supported Controllers</a></li>
              <li><a href="SpecialPlatformSupport.html" title="Special Platform Support">Special Platform Support</a></li>
	          <li><a href="Examples.html" title="Examples">Examples</a></li>
              <li><a href="Integration.html">Integrations</a></li>
	          <li><a href="Updating.html" title="Updating Rewired">Updating Rewired</a></li>
	          <li><a href="Troubleshooting.html" title="Troubleshooting">Troubleshooting</a></li>
              <li><a href="KnownIssues.html">Known Issues</a></li>
            </ul>
            <strong>Unity Help:</strong>
            <ul>
              <li><a href="http://docs.unity3d.com/Manual/" target="_blank">Unity Manual</a></li>
              <li><a href="http://docs.unity3d.com/ScriptReference/" target="_blank">Unity Script Reference</a></li>
              <li><a href="http://unity3d.com/learn/tutorials/modules" target="_blank">Unity Tutorials</a></li>
            </ul>
            <strong>Links:</strong>
            <ul>
              <li><a href="http://guavaman.com/projects/rewired">Rewired Website</a></li>
              <li><a href="http://guavaman.com/projects/rewired/docs">Web Documentation</a></li>
            </ul>
        </div>
        
    
    	<div class="main-body">
	        <div class="logo"><a href="http://guavaman.com/projects/rewired" title="Rewired"><img src="files/images/rewired-logo.png" width="173" height="139" alt="Rewired" /></a></div>
                     
            <h1>
            <!-- InstanceBeginEditable name="PageHeader" -->How To's
      <!-- InstanceEndEditable -->
            </h1>
            
			<!-- InstanceBeginEditable name="MainBody" -->

    <p><strong>Topics:</strong></p>
    <ul>
      <li><a href="#important-classes">Important classes</a></li>
      <li><a href="#get-player">Getting a Player</a></li>
      <li><a href="#get-input">Getting Input</a></li>
      <li><a href="#get-controller">Getting a Controller</a></li>
      <li><a href="#connect-disconnect-events">Receiving joystick connect and disconnect events</a></li>
      <li><a href="#assigning-joysticks">Assigning joysticks to players</a></li>
      <li><a href="#enabling-disabling-controller-maps">Enabling and disabling controller maps</a></li>
      <li><a href="#managing-controller-maps-runtime">Managing controller maps at runtime</a></li>
      <li><a href="#get-element-name-for-action">Displaying a button/axis/key name to the user for an Action</a></li>
      <li><a href="#get-contributing-input-sources">Getting contributing input sources for an Action</a></li>
      <li><a href="#last-used-controller">Determining which controller was last used</a></li>
      <li><a href="#calibrating-controller-axes">Calibrating controller axes</a></li>
      <li><a href="#Vibration-Rumble">Vibration/Rumble</a></li>
      <li><a href="#converting-scripts">Converting scripts from UnityEngine.Input to Rewired</a></li>
      <li><a href="#press-start-to-join">Implementing a &quot;Press Start to Join&quot; controller assignment system</a></li>
      <li><a href="#controller-mapping-screen">Creating a controller mapping screen</a></li>
      <li><a href="#saving-loading-controller-maps">Saving and loading controller maps</a></li>
      <li><a href="#saving-loading-calibration-maps">Saving and loading calibration maps</a></li>
      <li><a href="#modifying-input-behaviors-during-runtime">Modifying Input Behaviors during runtime</a></li>
      <li><a href="#on-screen-touch-controllers">Creating on-screen touch controllers</a></li>
      <li><a href="#new-controller-definitions">Creating new controller definitions</a></li>
      <li><a href="#new-controller-templates">Creating new controller templates</a></li>
      <li><a href="#add-controller-to-existing-controller-template">Adding a controller to an existing controller template</a></li>
      <li><a href="#excluding-controller-definitions">Excluding controller definitions</a></li>
      <li><a href="#identifying-joysticks-windows-fallback-or-webplayer">Identifying joysticks on Windows fallback or Windows Webplayer platforms</a></li>
      <li><a href="#hide-input-settings-launcher">Hiding input settings on the Unity launcher</a></li>
      <li><a href="#configuring-arcadeguns-g500">Configuring ArcadeGuns G-500 AimTrak Light Guns</a></li>
      <li><a href="#Logitech-G27">Logitech G27 Racing Wheel Support</a></li>
      <li><a href="#Saitek-TPM">Saitek Pro Flight TPM Panel Support</a></li>
      <li><a href="#dualshock-4-special-features">Using Sony DualShock 4 special features</a></li>
      <li><a href="#raildriver-special-features">Using P.I. Engineering Rail Driver special features</a></li>
      <li><a href="#xbox-one-controller-special-features">Using XBox One controller special features on XBox One platform</a></li>
      <li><a href="#unity-ui">Using Rewired to control Unity's new UI</a></li>
    </ul>
    <p>&nbsp;</p>
    <hr />
    <h3><a name="important-classes" id="important-classes"></a>Important classes</h3>
    <p>Rewired's API has been organized using helper classes to group methods and properties topically. This makes it easier to find the methods you are looking for through the IDE.</p>
    <p><strong>Global Information:</strong></p>
    <ul>
  <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_ReInput.htm">ReInput</a> - The main class for accessing all input-related information. </li>
  <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_ReInput_PlayerHelper.htm">ReInput.players</a> - Players and Player-related information. </li>
    <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_ReInput_ControllerHelper.htm">ReInput.controllers</a> - Controllers and controller-related information of all types.</li>
    <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_ReInput_MappingHelper.htm">ReInput.mapping</a> - Controller Map, Action, Input Behavior and other data in the Rewired Input Manager.</li>
    </ul>
    <p><strong>Player-Related Information:</strong></p>
    <ul>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Player.htm">Player</a> - Get input from the Player.</li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Player_ControllerHelper.htm">Player.controllers</a> - All controller-related information in a Player.</li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Player_ControllerHelper_MapHelper.htm">Player.controllers.maps</a> - All map-related information in a Player.</li>
    </ul>
    <p>&nbsp;</p>
    <p>More classes are listed in the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/N_Rewired.htm">API reference</a>.</p>
<p>&nbsp;</p>
    <hr />
    <h3><a name="get-player" id="get-player"></a>Getting a Player</h3>
<p>Get a Player by id or name through <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ReInput_PlayerHelper_GetPlayer.htm">ReInput.players.GetPlayer</a></p>
<p>More methods for accessing Players: <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_ReInput_PlayerHelper.htm" target="_blank">ReInput.players</a></p>
    <pre class="code">
using UnityEngine;
using Rewired;

public class MyClass : MonoBehaviour {
    public int playerId;
    private Player player;

    void Awake() {
        <span class="comment">// Get the Player for a particular playerId</span>
        player = ReInput.players.GetPlayer(playerId);

       <span class="comment">// Some more examples:</span>

       <span class="comment">// Get the System Player</span>
       Player systemPlayer = ReInput.players.GetSystemPlayer();

       <span class="comment">// Iterating through Players (excluding the System Player)</span>
       for(int i = 0; i &lt; ReInput.players.playerCount; i++) {
           Player p = ReInput.players.Players[i];
       }

       <span class="comment">// Iterating through Players (including the System Player)</span>
       for(int i = 0; i &lt; ReInput.players.allPlayerCount; i++) {
           Player p = ReInput.players.AllPlayers[i];
       }
    }
}</pre>
<p></p>
    <hr />
    <h3><a name="get-input" id="get-player2"></a>Getting Input</h3>
    <p>There are two primary ways to get input in Rewired:</p>
    <ol>
      <li>Polling for input - This is the most common method and is very similar to how you normally get input in Unity.</li>
      <li>Using input events - This method allows you to get input by registering for an event and receving a callback when that event takes place.</li>
    </ol>
<p><strong>Polling Method:</strong></p>
<p>Get input through the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Player.htm">Player</a> class.</p>
    <pre class="code">
using UnityEngine;
using Rewired;

public class MyClass : MonoBehaviour {
    public int playerId;
    private Player player;

    void Awake() {
        player = ReInput.players.GetPlayer(playerId);
    }

    void Update() {
        if(player.GetAxis(&quot;Move Horizontal&quot;) != 0.0f) {
            Debug.Log(&quot;Move Horizontal!&quot;);
        }

        if(player.GetButtonDown(&quot;Fire&quot;)) {
            Debug.Log(&quot;Fire!&quot;);
        }
    }
}    </pre>
<p><strong>Event Method:</strong></p>
<p>Use delegates to receive input events from a Player.</p>
<pre class="code">
public class MyClass : MonoBehaviour {
    public int playerId;
    private Player player;

    void Awake() {
        player = ReInput.players.GetPlayer(playerId);

        <span class="comment">// Add delegates to receive input events from the Player</span>
        
        <span class="comment">// This event will be called every frame any input is updated</span>
        player.AddInputEventDelegate(OnInputUpdate, UpdateLoopType.Update);

        <span class="comment">// This event will be called every frame the &quot;Fire&quot; action is updated</span>
        player.AddInputEventDelegate(OnFireUpdate, UpdateLoopType.Update, &quot;Fire&quot;);

        <span class="comment">// This event will be called when the &quot;Fire&quot; button is first pressed</span>
        player.AddInputEventDelegate(OnFireButtonDown, UpdateLoopType.Update, InputActionEventType.ButtonJustPressed, &quot;Fire&quot;);

        <span class="comment">// This event will be called when the &quot;Fire&quot; button is first released</span>
        player.AddInputEventDelegate(OnFireButtonUp, UpdateLoopType.Update, InputActionEventType.ButtonJustReleased, &quot;Fire&quot;);

        <span class="comment">// The update loop you choose for the event matters. Make sure your chosen update loop is enabled in</span>
        <span class="comment">// the Settings page of the Rewired editor or you won't receive any events.</span>
    }

    void OnInputUpdate(InputActionEventData data) {
        switch(data.actionName) { <span class="comment">// determine which action this is</span>
            case "Move Horizontal":
                if(data.GetAxis() != 0.0f) Debug.Log("Move Horizontal!");
                break;
            case "Fire":
                if(data.GetButtonDown()) Debug.Log("Fire!");
                break;
        }
    }

    void OnFireUpdate(InputActionEventData data) {
        if(data.GetButtonDown()) Debug.Log("Fire!");
    }

    void OnFireButtonDown(InputActionEventData data) {
        Debug.Log("Fire!");
    }

    void OnFireButtonUp(InputActionEventData data) {
        Debug.Log("Fire Released!");
    }
}</pre>
<p><strong>Controller Method:</strong></p>
<p>A third method would be to get input directly from a controller's buttons and axes. This is generally not the best choice as you will lose all the advantages of the player-centric system including mapping. Methods for accessing element values can be found in the respective controller classes:</p>
<ul>
  <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Joystick.htm">Joystick</a></li>
  <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Keyboard.htm">Keyboard</a></li>
  <li> <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Mouse.htm">Mouse</a></li>
  <li> <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_CustomController.htm">Custom Controller</a></li>
</ul>
<pre class="code">
void LogMouseValues() {
    Mouse mouse = ReInput.controllers.Mouse;
    Debug.Log(&quot;Left Mouse Button = &quot; + mouse.GetButton(0));
    Debug.Log(&quot;Right Mouse Button (Hold) = &quot; + mouse.GetButton(1));
    Debug.Log(&quot;Right Mouse Button (Down) = &quot; + mouse.GetButtonDown(1));
    Debug.Log(&quot;Right Mouse Button (Up) = &quot; + mouse.GetButtonUp(1));
}

void LogPlayerJoystickValues(Player player) {
    <span class="comment">// Log the button and axis values for each joystick assigned to this Player</span>
    for(int i = 0; i < player.joystickCount; i++) {
        Joystick joystick = player.Joysticks[i];
        Debug.Log(&quot;Joystick &quot; + i + &quot;:&quot;);
        LogJoystickElementValues(joystick); <span class="comment">// log all the element values in this joystick</span>
    }
}

void LogJoystickElementValues(Joystick joystick) {
    <span class="comment">// Log Joystick button values</span>
    for(int i = 0; i &lt; joystick.buttonCount; i++) {<br />        Debug.Log(&quot;Button &quot; + i + &quot; = &quot; + joystick.Buttons[i].value); <span class="comment">// get the current value of the button</span>
    }

    <span class="comment">// Log Joystick axis values</span>
    for(int i = 0; i &lt; joystick.axisCount; i++) {<br />        Debug.Log(&quot;Axis &quot; + i + &quot; = &quot; + joystick.Axes[i].value); <span class="comment">// get the current value of the axis</span>
    }
}</pre>
<p>&nbsp;</p>
<hr />
<h3><a name="get-controller" id="get-controller"></a>Getting a Controller</h3>
<p>You generally don't need to get controllers for normal gameplay input tasks, but there are certain times when you need to get a controller such as during controller remapping. There are a number of ways you can get controllers.</p>
<p><strong>To get  a specific controller:</strong><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ReInput_ControllerHelper_GetController.htm">ReInput.controllers.GetController</a><br />
<a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_GetController.htm">player.controllers.GetController</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_GetControllerWithTag.htm">player.controllers.GetControllerWithTag</a></p>
<p><strong>You can get the mouse from:</strong><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ReInput_ControllerHelper_Mouse.htm">ReInput.controllers.Mouse</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_Player_ControllerHelper_Mouse.htm">player.controllers.Mouse</a></p>
<p><strong>You can get the keyboard from:</strong><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ReInput_ControllerHelper_Keyboard.htm">ReInput.controllers.Keyboard</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_Player_ControllerHelper_Keyboard.htm">player.controllers.Keyboard </a></p>
<p><strong>You can loop through all controllers:</strong><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ReInput_ControllerHelper_Controllers.htm">ReInput.controllers.Controllers <br />
  </a><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ReInput_ControllerHelper_Joysticks.htm">ReInput.controllers.Joysticks</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ReInput_ControllerHelper_CustomControllers.htm">ReInput.controllers.CustomControllers</a></p>
<p><strong>You can loop through controllers assigned to a Player:</strong><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_Player_ControllerHelper_Joysticks.htm">player.controllers.Joysticks</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_Player_ControllerHelper_CustomControllers.htm">player.controllers.CustomControllers</a></p>
<p>&nbsp;</p>
<hr />
    <h3><a name="connect-disconnect-events" id="connect-disconnect-events"></a>Receiving joystick connect and disconnect events</h3>
    <p>To receive an event when a controller is connected, register for <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/E_Rewired_ReInput_ControllerConnectedEvent.htm">ReInput.ControllerConnectedEvent</a>.<br />
    To receive an event when a controller is fully disconnected, register for  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/E_Rewired_ReInput_ControllerDisconnectedEvent.htm">ReInput.ControllerDisconnectedEvent</a>.<br />
    To receive an event when a controller is about to be disconnected, register for <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/E_Rewired_ReInput_ControllerDisconnectedEvent.htm">ReInput.ControllerPreDisconnectEvent</a>.</p>
    <p>Note: Joysticks are not guaranteed to be available on Awake or Start on all platforms or input sources. If joysticks are available immediately to Rewired on Awake, joystick connected events will not be sent. If joystick availability is delayed, a controller connected event will be sent when Rewired detects the joystick. If you need to check for the presence of joysticks at the beginning of your game, you should always check in both Awake or Start and by subscribing to the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/E_Rewired_ReInput_ControllerConnectedEvent.htm">ReInput.ControllerConnectedEvent</a>.</p>
    <pre class="code">
using UnityEngine;
using Rewired;

public MyClass : MonoBehaviour {

    void Awake() {
        ReInput.ControllerConnectedEvent += OnControllerConnected;
        ReInput.ControllerDisconnectedEvent += OnControllerDisconnected;
        ReInput.ControllerPreDisconnectEvent += OnControllerPreDisconnect;
    }

    void OnControllerConnected(ControllerStatusChangedEventArgs args) {
        <span class="comment">// This function will be called when a controller is connected</span>
        <span class="comment">// You can get information about the controller that was connected via the args parameter</span>
        Debug.Log(&quot;A controller was connected! Name = &quot; + args.name + &quot; Id = &quot; + args.controllerId + &quot; Type = &quot; + args.controllerType);
    }

     void OnControllerDisconnected(ControllerStatusChangedEventArgs args) {
        <span class="comment">// This function will be called when a controller is fully disconnected</span>
        <span class="comment">// You can get information about the controller that was disconnected via the args parameter</span>
        Debug.Log(&quot;A controller was disconnected! Name = &quot; + args.name + &quot; Id = &quot; + args.controllerId + &quot; Type = &quot; + args.controllerType);
    }

     void OnControllerPreDisconnect(ControllerStatusChangedEventArgs args) {
        <span class="comment">// This function will be called when a controller is about to be disconnected</span>
        <span class="comment">// You can get information about the controller that is being disconnected via the args parameter</span>
        <span class="comment">// You can use this event to save the controller's maps before it's disconnected</span>
        Debug.Log(&quot;A controller is being disconnected! Name = &quot; + args.name + &quot; Id = &quot; + args.controllerId + &quot; Type = &quot; + args.controllerType);
    }
}</pre>
    <hr />
    <h3><a name="assigning-joysticks" id="assigning-joysticks"></a>Assigning joysticks to players</h3>
    <p>Joysticks will be assigned to Players automatically if you have enabled and configured joystick auto-assignment in the <a href="RewiredEditor.html#Settings">Rewired Editor under Settings</a>. However, if you wish to manually assign or unassign joysticks, you can do so with the following methods:</p>
    <p><strong>Player class:</strong></p>
    <ul>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_AddController.htm">player.controllers.AddController</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_RemoveController.htm">player.controllers.RemoveController</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_ContainsController.htm">player.controllers.ContainsController</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_ClearControllersOfType.htm">player.controllers.ClearControllersOfType</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Player_ControllerHelper_ClearAllControllers.htm">player.controllers.ClearAllControllers</a></li>
    </ul>
    <p><strong>ReInput class:</strong></p>
    <ul>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ReInput_ControllerHelper_IsControllerAssigned.htm">ReInput.controllers.IsControllerAssigned</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ReInput_ControllerHelper_IsCustomControllerAssignedToPlayer.htm">ReInput.controllers.IsControllerAssignedToPlayer</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ReInput_ControllerHelper_RemoveControllerFromAllPlayers.htm">ReInput.controllers.RemoveControllerFromAllPlayers</a></li>
    </ul>
    <p>&nbsp;</p>
    <p>Also, see <a href="#connect-disconnect-events">Receiving joystick connect and disconnect events</a> to get a notification when a controller is connected or disconnected.</p>
    <pre class="code">
<span class="comment">// Example: Shows how to assign Joysticks manually to the next Player that doesn't have one assigned.</span>

void Awake() {
    <span class="comment">// Listen for controller connection events</span>
    ReInput.ControllerConnectedEvent += OnControllerConnected;

    <span class="comment">// Assign each Joystick to a Player initially</span>
    foreach(Joystick j in ReInput.controllers.Joysticks) {
        if(ReInput.controllers.IsJoystickAssigned(j)) continue; <span class="comment">// Joystick is already assigned</span>

        <span class="comment">// Assign Joystick to first Player that doesn't have any assigned</span>
        AssignJoystickToNextOpenPlayer(j);
    }
}

<span class="comment">// This will be called when a controller is connected</span>
void OnControllerConnected(ControllerStatusChangedEventArgs args) {
    if(args.controllerType != ControllerType.Joystick) return; // skip if this isn't a Joystick
 
    <span class="comment">// Assign Joystick to first Player that doesn't have any assigned</span>
    AssignJoystickToNextOpenPlayer(ReInput.controllers.GetJoystick(args.controllerId));
}

void AssignJoystickToNextOpenPlayer(Joystick j) {
    foreach(Player p in ReInput.players.Players) {
        if(p.controllers.joystickCount > 0) continue; <span class="comment">// player already has a joystick</span>
        p.controllers.AddController(j, true); <span class="comment">// assign joystick to player</span>
        return;
    }
}</pre>
<p>&nbsp;</p>
<hr />
    <h3><a name="enabling-disabling-controller-maps" id="enabling-disabling-controller-maps"></a>Enabling and disabling controller maps</h3>
    <p><a href="ControllerMaps.html">Controller Maps</a> can be enabled or disabled at will via scripting. This can be useful if you want to change game modes and have a different set of controls become active. For example, opening a menu screen. Disabled controller maps will not return any value when the Player is queried for an Action's input value. Controller Maps are stored in the <a href="http://guavaman.com/projects/rewired/docs/api-reference/?topic=html/T_Rewired_Player.htm">Player</a> class.</p>
    <p>The easiest way to enable and disable maps in a Player is to use the following methods:</p>
    <ul>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_SetAllMapsEnabled.htm">player.controllers.maps.SetAllMapsEnabled</a> - Set enabled state on all maps owned by the Player or all maps for a specific controller type.</li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_SetMapsEnabled.htm">player.controllers.maps.SetMapsEnabled</a> - Set enabled state on a group of maps owned by the Player by controller type, category, and layout.</li>
    </ul>
    <p>You can also enable and disable maps one by one by accessing the maps through Player:</p>
    <ul>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_GetMap.htm">player.controllers.maps.GetMap</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_GetMaps.htm">player.controllers.maps.GetMaps</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_GetAllMaps.htm">player.controllers.maps.GetAllMaps</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_GetAllMapsInCategory.htm">player.controllers.maps.GetAllMapsInCategory</a></li>
    </ul>
    <p>Once you have the map, enable or disable it by setting <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ControllerMap_enabled.htm">controllerMap.enabled</a> = true or <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ControllerMap_enabled.htm">controllerMap.enabled</a> = false. Disabled maps will not contribute to input.</p>
<p>Example: Set enabled state on all of a Player's controller maps in a certain category.</p>
    <pre class="code">
using Rewired;

public class MyClass {
    void SetEnabledStateOnMapsInCategory(Player player, string categoryName, bool state) {

        <span class="comment">// The quick way</span>
        player.controllers.maps.SetMapsEnabled(state, categoryName);

        <span class="comment">// The manual way</span>
        foreach(ControllerMap map in player.controllers.maps.GetAllMapsInCategory(categoryName)) {
            map.enabled = state; <span class="comment">// set the enabled state on the map</span>
        }
    }
}    </pre>
    <p>&nbsp;</p>
    <hr />
    <h3><a name="managing-controller-maps-runtime" id="enabling-disabling-controller-maps2"></a>Managing controller maps at runtime</h3>
    <p><a href="ControllerMaps.html">Controller Maps</a> can be added, removed, cleared, and reloaded during gameplay via scripting. This can be useful if you want to load the default controller maps as defined in the Rewired Editor after having made changes, or to load a controller map in a different Layout. Controller Maps are stored in the <a href="http://guavaman.com/projects/rewired/docs/api-reference/?topic=html/T_Rewired_Player.htm">Player</a> class.</p>
    <p>Methods:</p>
    <ul>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_LoadMap.htm">player.controllers.maps.LoadMap</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Player_ControllerHelper_MapHelper_LoadDefaultMaps.htm">player.controllers.maps.LoadDefaultMaps</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_AddMap.htm">player.controllers.maps.AddMap</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_RemoveMap.htm">player.controllers.maps.RemoveMap</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Player_ControllerHelper_MapHelper_ClearAllMaps.htm">player.controllers.maps.ClearAllMaps</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_ClearMaps.htm">player.controllers.maps.ClearMaps</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Methods_T_Rewired_Player_ControllerHelper_MapHelper.htm">More methods for controller map management</a></li>
      </ul>
    <p>&nbsp;</p>
<hr />
    <h3><a name="get-element-name-for-action" id="get-element-name-for-action"></a>Displaying a button/axis/key name to the user for an Action    </h3>
    <p>If you want to display some help text on the screen telling the user which button/key/axis to press for a particular Action, you can get this information from the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ActionElementMap_elementIdentifierName.htm">ActionElementMap.elementIdenfitierName</a> property. The following example shows various ways to get this information for an Action.</p>
    <pre class="code">Player player = Rewired.ReInput.players.GetPlayer(0);

<span class="comment">// If set to true, only enabled maps will be returned</span>
bool skipDisabledMaps = true;

<span class="comment">// Get the first ActionElementMap of any type with the Action "Fire"</span>
Debug.Log(player.controllers.maps.GetFirstElementMapWithAction("Fire", skipDisabledMaps).elementIdentifierName);

<span class="comment">// Get the first button map with the Action "Jump"</span>
Debug.Log(player.controllers.maps.GetFirstButtonMapWithAction("Jump", skipDisabledMaps).elementIdentifierName);

<span class="comment">// Get the first axis map with the Action "Move Horizontal"</span>
Debug.Log(player.controllers.maps.GetFirstAxisMapWithAction("Move Horizontal", skipDisabledMaps).elementIdentifierName);

<span class="comment">// Loop over all ActionElementMaps of any type with the Action "Fire"</span>
foreach(var aem in player.controllers.maps.ElementMapsWithAction("Fire", skipDisabledMaps)) {
    Debug.Log(aem.elementIdentifierName);
}

<span class="comment">// Loop over all button maps with the Action "Fire"</span>
foreach(var aem in player.controllers.maps.ButtonMapsWithAction("Fire", skipDisabledMaps)) {
    Debug.Log(aem.elementIdentifierName);
}

<span class="comment">// Loop over all Axis maps with the Action "Move Horizontal"</span>
foreach(var aem in player.controllers.maps.AxisMapsWithAction("Move Horizontal", skipDisabledMaps)) {
    Debug.Log(aem.elementIdentifierName);
}

<span class="comment">// All elements mapped to all joysticks in the player</span>
foreach(Joystick j in player.controllers.Joysticks) {

    <span class="comment">// Loop over all Joystick Maps in the Player for this Joystick</span>
    foreach(JoystickMap map in player.controllers.maps.GetMaps<JoystickMap>(j.id)) {

        <span class="comment">// Loop over all button maps</span>
        foreach(ActionElementMap aem in map.ButtonMaps) {
            Debug.Log(aem.elementIdentifierName + " is assigned to Button " + aem.elementIndex + " with the Action " + ReInput.mapping.GetAction(aem.actionId).name);
        }

        <span class="comment">// Loop over all axis maps</span>
        foreach(ActionElementMap aem in map.AxisMaps) {
            Debug.Log(aem.elementIdentifierName + " is assigned to Axis " + aem.elementIndex + " with the Action " + ReInput.mapping.GetAction(aem.actionId).name);
        }

        <span class="comment">// Loop over all element maps of any type</span>
        foreach(ActionElementMap aem in map.AllMaps) {
            if(aem.elementType == ControllerElementType.Axis) {
                Debug.Log(aem.elementIdentifierName + " is assigned to Axis " + aem.elementIndex + " with the Action " + ReInput.mapping.GetAction(aem.actionId).name);
            } else if(aem.elementType == ControllerElementType.Button) {
                Debug.Log(aem.elementIdentifierName + " is assigned to Axis " + aem.elementIndex + " with the Action " + ReInput.mapping.GetAction(aem.actionId).name);
            }
        }
    }
}</pre>
    <p>&nbsp;</p>
    <hr />
    <h3><a name="get-contributing-input-sources" id="get-contributing-input-sources"></a>Getting contributing input sources for an Action</h3>
<p>You can get information about all the input sources currently contributing to the value of an Action in a Player. There are several methods available to get this information:</p>
<ul>
  <li>  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_GetCurrentInputSources.htm">Player.GetCurrentInputSources</a></li>
  <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_IsCurrentInputSource.htm">Player.IsCurrentInputSource</a></li>
  <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_InputActionEventData_GetCurrentInputSources.htm">InputActionEventData.GetCurrentInputSource</a></li>
  <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_InputActionEventData_IsCurrentInputSource.htm">InputActionEventData.IsCurrentInputSource </a></li>
</ul>
<p>You can either retrieve a list of all input sources currently contributing to input or query whether a controller type or an individual controller contributed input.</p>
<p>You can get data about the current input sources and then use that to tell which controllers or even which individual elements on the controllers were used to provide the input in the current frame.</p>
<p>See <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_InputActionSourceData.htm">InputActionSourceData</a> for more information on data returned.</p>
<p>&nbsp;</p>
    <hr />
    <h3><a name="last-used-controller" id="last-used-controller"></a>Determining which controller was last used</h3>
    <p>You can determine which controller or controller type was last used by any Player or an individual Player. One common use of this technique is to switch on-screen glyphs depending on whether the player is using a mouse/keyboard or a joystick.</p>
    <p>Use the following methods:</p>
    <ul>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ReInput_ControllerHelper_GetLastActiveController.htm">ReInput.controllers.GetLastActiveController</a></li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_GetLastActiveController.htm">Player.controllers.GetLastActiveController</a></li>
    </ul>
    <p>Then you can get the controller type from <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_Controller_type.htm">Controller.type.</a></p>
    <pre class="code">
<span class="comment">// Get last controller from a Player and the determine the type of controller being used</span>
Controller controller = player.GetLastActiveController();
if(controller != null) {
  switch(controller.type) {
    case ControllerType.Keyboard:
      // Do something for keyboard
      break;
    case ControllerType.Joystick:
      // Do something for joystick
      break;
    case ControllerType.Mouse:
      // Do something for mouse
      break;
    case ControllerType.Custom:
      // Do something custom controller
      break;
  }
}</pre>
<p>&nbsp;</p>
<hr />
    <h3><a name="calibrating-controller-axes" id="calibrating-controller-axes"></a>Calibrating controller axes</h3>
    <p>The general process of calibrating controller axes is as follows:</p>
    <ol>
      <li>Get the controller (see <a href="#get-controller">Getting a Controller</a> for more information.)</li>
      <li>Get the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_CalibrationMap.htm">calibration map</a></li>
      <li>Set the calibrated values</li>
    </ol>
    <p>You can see an example of axis calibration in Rewired/Examples/ControlRemapping1.<br />
    </p>
<p><strong>Useful API Reference:</strong></p>
<p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_CalibrationMap.htm">CalibrationMap<br />
</a><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_AxisCalibration.htm">AxisCalibration</a><br />
<a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_AxisCalibrationData.htm">AxisCalibrationData</a><br />
<a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ControllerWithAxes_calibrationMap.htm">Joystick.calibrationMap<br />
</a><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_CalibrationMapSaveData.htm">CalibrationMapSaveData</a><br />
<a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Joystick_GetCalibrationMapSaveData.htm">Joystick.GetCalibrationMapSaveData</a></p>
<p>&nbsp;</p>
<hr />
<h3><a name="Vibration-Rumble" id="Vibration-Rumble"></a>Vibration/Rumble</h3>
<p>Rewired supports vibration on compatible controllers including the XBox 360 gamepad in the Windows, Windows Store, and Linux platforms.</p>
<p>Important: You must have XInput enabled in the Rewired Input Manager on Windows platforms.</p>
<p>Just get the controller(s) from the Player class and set the motor levels on 
  each of them. </p>
<pre class="code">
// Set vibration by motor type
foreach(Joystick j in player.controllers.Joysticks) {
    if(!j.supportsVibration) continue;
    j.SetVibration(leftMotorValue, rightMotorValue);
}

// Set vibration by motor index
foreach(Joystick j in player.controllers.Joysticks) {
    if(!j.supportsVibration) continue;
    if(j.vibrationMotorCount &gt; 0) j.SetVibration(0, leftMotorValue);
    if(j.vibrationMotorCount &gt; 1) j.SetVibration(1, rightMotorValue);
}

// Stop vibration
foreach(Joystick j in player.controllers.Joysticks) {
    j.StopVibration();
}</pre>
<p>This would set vibration on all controllers assigned to the player.</p>
<p>There are also these functions/properties in the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Joystick.htm">Joystick</a> class:<br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Joystick_SetVibration.htm">Joystick.SetVibration</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Joystick_StopVibration.htm">Joystick.StopVibration</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/F_Rewired_Joystick_supportsVibration.htm">Joystick.supportsVibration</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_Joystick_vibrationLeftMotor.htm">Joystick.vibrationLeftMotor</a><br />
  <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_Joystick_vibrationRightMotor.htm">Joystick.vibrationRightMotor</a></p>
<p>&nbsp;</p>
<hr />
<h3><a name="converting-scripts" id="converting-scripts"></a>Converting scripts from UnityEngine.Input to Rewired</h3>
<p>Converting a script from UnityEngine.Input is a very straightforward process for a single player game. For a quick conversion, simply do a two find and replace operations:</p>
<ul>
  <li> &quot;Input.GetButton&quot; -&gt; &quot;Rewired.ReInput.players.GetPlayer(0).GetButton&quot;</li>
  <li>&quot;Input.GetAxis&quot; -&gt; &quot;Rewired.ReInput.players.GetPlayer(0).GetAxis&quot;</li>
</ul>
<p>This will get the value of each Action from Player 0 for all GetButton, GetButtonDown, GetButtonUp, GetAxis, and GetAxisRaw calls.</p>
<p>You will also need to create the Actions in the Rewired Input Manager that match the string names expected in the code. And of course you will have to create Keyboard, Mouse, Joystick, and/or Custom Controller maps and assign them to Players as is standard Rewired practice.</p>
<p>If your code has Input.GetKey calls, if you want those to instead use Rewired Actions, you will want to change these to &quot;Rewired.ReInput.players.GetPlayer(0).GetButton&quot; and replace the Unity KeyCode with the name or id of the Action you want to use.</p>
<p>You could also cache the Player object on Awake for the Player in question and use that variable in the find/replace operation, but the above example provides a quick method to convert most scripts that use UnityEngine.Input to Rewired.</p>
<p>&nbsp;</p>
<hr />
<h3><a name="press-start-to-join" id="press-start-to-join"></a>Implementing a &quot;Press Start to Join&quot; controller assignment system</h3>
<p>Normally, Rewired will assign controllers to Players when each controller is detected based on settings in the Rewired Input Manager -&gt; Settings page. This will assign a controller to each Player in order as they become available so that the first joystick is assigned to Player 0, the second to Player 1, and so on. But the question has come up many times as to how to be able to let users just pick up any attached controller and press &quot;Start&quot;, then have that player join as the next available Player with that controller assigned. This kind of assignment method isn't as straightforward to implement.</p>
<p>First you should understand a little bit how controller maps work. Controller maps are loaded by the Player, not the Controller, therefore there is no Action named &quot;Start&quot; in that controller from which to generate input unless you assign that controller to a Player first. Because if this, you cannot simply ask each unassigned controller for the value of &quot;Start&quot; to determine if a player wants to join because it doesn't have access to any controller maps.<br />
</p>
<p>There are various ways this assignment scheme can be achieved. Each method has its own advantages and disadvantages. Please read through them and decide which is most appropriate for your game.</p>
<p><strong>Method 1: Using a variable Rewired.Player as an input source for your own Player object.</strong><br />
</p>
<ol>
  <li>Make your Players (let's say Player 0 – 3) in the editor.</li>
  <li>Assign them all joystick maps for the controllers you want to support.</li>
  <li>Create a &ldquo;Start&rdquo; action and be sure it is assigned in the controller maps you assigned to the Players on some button -- preferably, multiple buttons just to be sure in case a particular controller has no Start button (or &ldquo;Center 2&rdquo; as defined in the <a href="http://guavaman.com/projects/rewired/docs/ControllerMaps.html#dual-analog-gamepad-template" target="_blank" rel="nofollow">Dual Analog Gamepad Template</a>.) A safe bet would be to put it on &ldquo;Center 2&rdquo; and &ldquo;Action Bottom Row 1&rdquo; for the Dual Analog Gamepad Template, and Button 0 on <a href="http://guavaman.com/projects/rewired/docs/ControllerMaps.html#unknown-controllers" target="_blank" rel="nofollow">Unknown Controller</a> (if you're defining an Unknown Controller map).</li>
  <li>Leave controller auto assignment enabled. Rewired will give each Rewired.Player a controller if available.</li>
  <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ReInput_PlayerHelper_Players.htm" target="_blank" rel="nofollow">Loop through all Rewired.Players</a> and check for player.GetButtonDown(&ldquo;Start&rdquo;).</li>
  <li>Now in your game code, simply assign whichever Rewired.Player returned TRUE to your game-side player object. Your game-side player object may be Player[0], but the Rewired.Player doesn&rsquo;t have to be. The user could press a button on the controller assigned to Rewired.Player[3], but you can still then use Rewired.Player[3] as the input source for your game-side Player[0].</li>
</ol>
<p><br />
  If you also support Keyboard and Mouse, at that point you might want to go ahead and load the appropriate keyboard map layouts for your Player[0] into Rewired.Player[3]. This works best if keyboard layouts for the various in-game players will be fixed. IE: Player 1 always uses the WASD set, Player 2 always uses JIKM, etc. (There are ways to make this assignment dynamic too but that's not covered here.)</p>
<p><strong>Method 2: Easy but does not detect &quot;Start&quot;, only any button press:</strong></p>
<ol>
  <li><a href="RewiredEditor.html#settings">Disable controller auto assignment</a> in the Rewired Editor.</li>
  <li>In your script, <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ReInput_ControllerHelper_Joysticks.htm" target="_blank" rel="nofollow">iterate over all joysticks</a> and check for <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Controller_GetAnyButtonDown.htm" target="_blank">any button press</a>.</li>
  <li><a href="#assigning-joysticks">Assign that joystick</a> to the first player.</li></ol>
    <p><strong>Method 3: Detect &quot;Start&quot; button press manually:</strong></p>
    <ol>
      <li> <a href="RewiredEditor.html#settings">Disable controller auto assignment</a> in the Rewired Editor.</li>
      <li>  <a href="#assigning-joysticks">Assign all controllers</a> to the System Player on start so we can detect the result of Actions.</li>
      <li>  <a href="#get-input">Check for the value of the &quot;Start&quot; Action</a> you've created and assigned to the Start button or other appropriate button in your controller maps.</li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Player_ControllerHelper_MapHelper_GetMaps.htm" target="_blank" rel="nofollow">Loop through the controller maps</a> in the System Player <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_Player_ControllerHelper_Joysticks.htm" target="_blank" rel="nofollow">for each joystick</a>, <a href="http://http//guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ControllerMap_ButtonMaps.htm" target="_blank" rel="nofollow">loop through each button map</a> looking for the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ActionElementMap_actionId.htm" target="_blank" rel="nofollow">actionId of your &quot;Start&quot; action</a>. (Or use the<a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ControllerMap_GetButtonMapsWithAction_1.htm" target="_blank" rel="nofollow"> ControllerMap.GetButtonMapsWithAction </a>method instead.)</li>
      <li> Then use the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ActionElementMap_elementIndex.htm" target="_blank" rel="nofollow">elementIndex in the button map</a> to find which button index corresponds to the &quot;Start&quot; action in that controller.</li>
      <li> In each controller, then <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Controller_GetButton.htm" target="_blank" rel="nofollow">check the value of the button at that index </a>to see if that was the controller that was activated.</li>
      <li>If it was, <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Player_ControllerHelper_AddController.htm" target="_blank" rel="nofollow">assign that controller to Player 1 and deassign it from System</a>.</li>
</ol>
  </ol>
  <p>    What you're essentially doing here is working backwards from the result of the Action trying to find what controller element(s) contributed to this final combined value. It goes against the source controller-agnostic nature of Rewired's player-centric system, but it is possible to do.<br />
    <br />
    A quicker but less accurate method would be to do step 1-3 above then:<strong><br />
      </strong><br />
    Loop through each controller in the System Player and <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Controller_GetLastTimeAnyButtonPressed.htm" target="_blank" rel="nofollow">find out which controller was the last to have any button pressed</a> and assign that controller to the Player.<br />
    <br />
    This isn't perfect since any button could have been pressed on any controller besides the ones assigned to the &quot;Start&quot; action, but in most cases it would probably work fine.<br />
    <br />
    There are also other functions to get the last active controller, but they won't help you here because you're only concerned with the &quot;Start&quot; button press and not axes, etc.<br />
    <br />
    <strong>Method 4:</strong> This method only works if you know your users are going to only be using one specific controller type (such as an Xbox controller on an Xbox system).<br />
    </p>
  <ol>
    <li>Use <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ControllerPollingInfo_elementIdentifierId.htm" target="_blank" rel="nofollow">ReInput.controllers.polling.PollAllControllersForAllButtons</a> to poll for button presses.</li>
    <li>Check the returned <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ControllerPollingInfo_elementIdentifierId.htm" target="_blank" rel="nofollow">ControllerPollingInfo.elementIdentifierId </a>or <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ControllerPollingInfo_elementIdentifierName.htm" target="_blank" rel="nofollow">ControllerPollingInfo.elementIdentifierName </a>to determine which button was pressed. 
    </li>
  </ol>
<hr />
    <h3><a name="controller-mapping-screen" id="controller-mapping-screen"></a>Creating a controller mapping screen</h3>
    <p>Rewired now includes <a href="ControlMapper.html">Control Mapper</a>, a customizable UI control mapping system built with uGUI that should fit the needs of many games. Please see <a href="ControlMapper.html">Control Mapper</a> for more information.</p>
    <p><strong>Creating a mapping screen from scratch</strong></p>
    <p>Creating a mapping screen can be a difficult task. To get you started, see the example mapping screen in Rewired/Examples/ControlRemapping1. You should be able to adapt this remapping example to fit the needs of your game. The example uses Unity's legacy GUI system.</p>
    <p>Every game's needs are different with regards to user mapping screens. The example project was built for a fairly complex game with a number of players and various game modes and supports saving and loading maps, controller assignment, element remapping, calibration, conflict checking, and more. You should be able to learn what you need to from the example project to customize your own mapping screen.</p>
    <p><strong>IMPORTANT NOTE:</strong><br />
    The ControlRemapping1 demo is  2,000 lines of code. Do not be afraid of reading through the code. The vast majority of that code is GUI code to handle all the modal boxes and such. There is a wealth of information in this demo.</p>
    <p>Just as a brief summary, the basic process for changing an element's mapping goes like this:</p>
    <ol>
      <li> <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ReInput_PlayerHelper_GetPlayer.htm">Get the Player</a> for which you are changing element mappings.</li>
      <li>Get the ControllerMap you want to modify from the Player.<br />
        <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Player_ControllerHelper_MapHelper.htm">Various functions here</a> can help in finding it. For example:<br />
        <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_GetMap.htm">player.controllers.maps.GetMap</a></li>
      <li>Modify an existing ActionElementMap or create a new one with your new assignment. You have your choice of ways to do this, some of which are:<br />
        <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ControllerMap_ReplaceOrCreateElementMap.htm">ControllerMap.ReplaceOrCreateElementMap</a><br />
        <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ControllerMap_ReplaceElementMap.htm">ControllerMap.ReplaceElementMap</a><br />
        <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ControllerMap_GetFirstElementMapWithAction.htm">ControllerMap.GetFirstElementMapWithAction</a> (then modify its properties directly)<br />
        <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ControllerMap_GetElementMapsWithAction.htm">ControllerMap.GetElementMapsWithAction</a><br />
        <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Methods_T_Rewired_ControllerMap.htm">There are more methods here.</a></li>
    </ol>
<p> Not that the above summary does not include the extra steps as shown in the demo which cover conflict checking, how to map axes to buttons and vice versa, dealing with split axes, how to poll for input, saving/loading, and a whole lot more. That's all detailed in the demo, so please read through it to learn how it's done.</p>
    <p><strong>IMPORTANT NOTE 2:<br />
    </strong>Creating your own control remapping system is not for beginners and requires patience and a certain level of programming skill. If you do not have the necessary programming skills, patience, or willingness to roll up your sleeves and dig into the code to learn how to do it, you shouldn't attempt it. If your programming skills are at a level where you need a step-by-step tutorial, this topic is too advanced for you. The purpose of this example is to learn the API. If you are looking for a drop-in control remapping system that doesn't require coding, please see <a href="ControlMapper.html">Control Mapper</a>.</p>
<p>&nbsp;</p>
<hr />
    <h3><a name="saving-loading-controller-maps" id="saving-loading-controller-maps"></a>Saving and loading controller maps</h3>
    <p><a href="UserDataStore.html">UserDataStore</a> is a class designed to help with saving and loading of controller maps, Input Behaviors, calibration settings, and more. Please see <a href="UserDataStore.html">User Data Store</a> for more information.</p>
    <p>There are several steps involved in saving and loading controller maps.</p>
<p><strong>Saving:</strong></p>
    <ol>
      <li>Get the save data from each Player in XML format.</li>
      <li>Save the data to a storage medium.</li>
    </ol>
    <p><strong>Loading:</strong></p>
    <ol>
      <li>Identify the controllers you want to load maps for.</li>
      <li>Load the map data in XML format.</li>
      <li>Set the map data in the Player.</li>
    </ol>
    <p>Rewired  includes a basic system for storing the saved XML data -- <a href="UserDataStore.html">UserDataStore_PlayerPrefs</a> which may not be suitable for everyone. Since every game and platform may have different requirements for data storage, you will probably want to write your own data storage system for your specific needs. You will have to save the data in a format most suitable to your game and platform. Possible options are PlayerPrefs, a database, binary or text files, cloud storage, etc. (<a href="UserDataStore.html">UserDataStore</a> can optionally be extended to support any storage medium.)<br />
    </p>
    <p>The example mapping demo in Rewired/Examples/ControlRemapping1 includes saving and loading of Controller Maps, Axis Calibration Maps, and Input Behaviors. See this demo project to learn the process of saving and loading. Note: The demo project uses PlayerPrefs for the data storage medium. This is not ideal, but was done for simplicity and cross-platform compatibility for the example. It should not be difficult to substitute another storage medium suitable to your platform.    </p>
    <p><strong>Example Code from the ControlRemapping1 (see example in Rewired/Examples/ControlRemapping1 for complete code)</strong></p>
    <pre class="code">private void SaveAllMaps() {
    <span class="comment">// This example uses PlayerPrefs because its convenient, though not efficient, but you could use any data storage method you like.</span>

    IList&lt;Player&gt; allPlayers = ReInput.players.AllPlayers;
    for(int i = 0; i &lt; allPlayers.Count; i++) {
        Player player = allPlayers[i];

        <span class="comment">// Get all savable data from player</span>
        PlayerSaveData playerData = player.GetSaveData(true);

        <span class="comment">// Save Input Behaviors</span>
        foreach(InputBehavior behavior in playerData.inputBehaviors) {
            string key = GetInputBehaviorPlayerPrefsKey(player, behavior);
            PlayerPrefs.SetString(key, behavior.ToXmlString()); <span class="comment">// save the behavior to player prefs in XML format</span>
        }

        <span class="comment">// Save controller maps</span>
        foreach(ControllerMapSaveData saveData in playerData.AllControllerMapSaveData) {
            string key = GetControllerMapPlayerPrefsKey(player, saveData);
            PlayerPrefs.SetString(key, saveData.map.ToXmlString()); <span class="comment">// save the map to player prefs in XML format</span>
        }
    }

    <span class="comment">// Save joystick calibration maps</span>
    foreach(Joystick joystick in ReInput.controllers.Joysticks) {
        JoystickCalibrationMapSaveData saveData = joystick.GetCalibrationMapSaveData();
        string key = GetJoystickCalibrationMapPlayerPrefsKey(saveData);
        PlayerPrefs.SetString(key, saveData.map.ToXmlString()); <span class="comment">// save the map to player prefs in XML format</span>
    }

    <span class="comment">// Save changes to PlayerPrefs</span>
    PlayerPrefs.Save();
}

private void LoadAllMaps() {
    <span class="comment">// This example uses PlayerPrefs because its convenient, though not efficient, but you could use any data storage method you like.</span>

    IList&lt;Player&gt; allPlayers = ReInput.players.AllPlayers;
    for(int i = 0; i &lt; allPlayers.Count; i++) {
        Player player = allPlayers[i];

        <span class="comment">// Load Input Behaviors - all players have an instance of each input behavior so it can be modified</span>
        IList&lt;InputBehavior&gt; behaviors = ReInput.mapping.GetInputBehaviors(player.id); <span class="comment">// get all behaviors from player</span>
        for(int j = 0; j &lt; behaviors.Count; j++) {
            string xml = GetInputBehaviorXml(player, behaviors[j].id); <span class="comment">// try to the behavior for this id</span>
            if(xml == null || xml == string.Empty) continue; <span class="comment">// no data found for this behavior</span>
            behaviors[j].ImportXmlString(xml); <span class="comment">// import the data into the behavior</span>
        }

        <span class="comment">// Load the maps first and make sure we have them to load before clearing</span>

        <span class="comment">// Load Keyboard Maps</span>
        List&lt;string&gt; keyboardMaps = GetAllControllerMapsXml(player, true, ControllerType.Keyboard, ReInput.controllers.Keyboard);

        <span class="comment">// Load Mouse Maps</span>
        List&lt;string&gt; mouseMaps = GetAllControllerMapsXml(player, true, ControllerType.Mouse, ReInput.controllers.Mouse); <span class="comment">// load mouse controller maps</span>
        
        <span class="comment">// Load Joystick Maps</span>
        bool foundJoystickMaps = false;
        List&lt;List&lt;string&gt;&gt; joystickMaps = new List&lt;List&lt;string&gt;&gt;();
        foreach(Joystick joystick in player.controllers.Joysticks) {
            List&lt;string&gt; maps = GetAllControllerMapsXml(player, true, ControllerType.Joystick, joystick);
            joystickMaps.Add(maps);
            if(maps.Count &gt; 0) foundJoystickMaps = true;
        }
        
        <span class="comment">// Now add the maps to the controller</span>

        <span class="comment">// Keyboard maps</span>
        if(keyboardMaps.Count &gt; 0) player.controllers.maps.ClearMaps(ControllerType.Keyboard, true); <span class="comment">// clear only user-assignable maps, but only if we found something to load. Don't _really_ have to clear the maps as adding ones in the same cat/layout will just replace, but let's clear anyway.</span>
        player.controllers.maps.AddMapsFromXml(ControllerType.Keyboard, 0, keyboardMaps); <span class="comment">// add the maps to the player</span>

        <span class="comment">// Joystick maps</span>
        if(foundJoystickMaps) player.controllers.maps.ClearMaps(ControllerType.Joystick, true); <span class="comment">// clear only user-assignable maps, but only if we found something to load. Don't _really_ have to clear the maps as adding ones in the same cat/layout will just replace, but let's clear anyway.</span>
        int count = 0;
        foreach(Joystick joystick in player.controllers.Joysticks) {
            player.controllers.maps.AddMapsFromXml(ControllerType.Joystick, joystick.id, joystickMaps[count]); <span class="comment">// add joystick controller maps to player</span>
            count++;
        }

        <span class="comment">// Mouse Maps</span>
        if(mouseMaps.Count &gt; 0) player.controllers.maps.ClearMaps(ControllerType.Mouse, true); <span class="comment">// clear only user-assignable maps, but only if we found something to load. Don't _really_ have to clear the maps as adding ones in the same cat/layout will just replace, but let's clear anyway.</span>
        player.controllers.maps.AddMapsFromXml(ControllerType.Mouse, 0, mouseMaps); <span class="comment">// add the maps to the player</span>
    }

    <span class="comment">// Load joystick calibration maps</span>
    foreach(Joystick joystick in ReInput.controllers.Joysticks) {
        joystick.ImportCalibrationMapFromXmlString(GetJoystickCalibrationMapXml(joystick)); <span class="comment">// load joystick calibration map if any</span>
    }
}</pre>
    <p><strong>Loading the Default Controller Maps:</strong></p>
<p>Default controller maps are stored in the Rewired Input Manager. You can load the defaults for a Player by using these methods:</p>
    <ul>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Player_ControllerHelper_MapHelper_LoadDefaultMaps.htm">player.controllers.maps.LoadDefaultMaps</a> - Loads all default maps from the Rewired Input Manager for all currently-connected devices. Replaces any existing maps already existing in Player.</li>
      <li><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_Player_ControllerHelper_MapHelper_LoadMap.htm">player.controllers.maps.LoadMap</a> - Loads a single map from the Rewired Input Manager.</li>
    </ul>
    <p>&nbsp;</p>
    <p><strong>Useful API Reference:</strong></p>
<p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Player_GetSaveData.htm">Player.GetSaveData</a> - Get all save data from the player at once. This includes controller map data.</p>
    <p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Player_ControllerHelper_MapHelper.htm">player.controllers.maps</a> - Methods to get, set, and work with controller maps in Player.</p>
    <p>&nbsp;</p>
<hr />
    <h3><a name="saving-loading-calibration-maps" id="saving-loading-calibration-maps"></a>Saving and loading calibration maps</h3>
    <p><a href="UserDataStore.html">UserDataStore</a> is a class designed to help with saving and loading of controller maps, Input Behaviors, calibration settings, and more. Please see <a href="UserDataStore.html">User Data Store</a> for more information.</p>
    <p>The process for saving and loading calibration maps is very similar to <a href="#saving-loading-controller-maps">Saving and loading controller maps</a>, except instead of getting the maps from the Player, you must get the Calibration Map data from the controllers themselves.</p>
    <p><strong>Example Code from the ControlRemapping1 (see example in Rewired/Examples/ControlRemapping1 for complete code)</strong></p>
    <pre class="code">private void SaveAllMaps() {
    <span class="comment">// ... Removed controller map saving code</span>

    <span class="comment">// Save joystick calibration maps</span>
    foreach(Joystick joystick in ReInput.controllers.Joysticks) {
        JoystickCalibrationMapSaveData saveData = joystick.GetCalibrationMapSaveData();
        string key = GetJoystickCalibrationMapPlayerPrefsKey(saveData);
        PlayerPrefs.SetString(key, saveData.map.ToXmlString()); <span class="comment">// save the map to player prefs in XML format</span>
    }

    <span class="comment">// Save changes to PlayerPrefs</span>
    PlayerPrefs.Save();
}

private void LoadAllMaps() {
    <span class="comment">// ... Removed controller map loading code</span>

    <span class="comment">// Load joystick calibration maps</span>
    foreach(Joystick joystick in ReInput.controllers.Joysticks) {
        joystick.ImportCalibrationMapFromXmlString(GetJoystickCalibrationMapXml(joystick)); <span class="comment">// load joystick calibration map if any</span>
    }
}    </pre>
    <p><strong>Useful API Reference:</strong></p>
<p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Player_ControllerHelper_MapHelper.htm">player.controllers.maps</a> - Methods to get, set, and work with controller maps in Player.</p>
    <p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ControllerWithAxes_calibrationMap.htm">Joystick.calibrationMap</a> - Get the calibration map from the controller</p>
    <p><span class="code"><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_Joystick_GetCalibrationMapSaveData.htm">Joystick.GetCalibrationMapSaveData</a></span> - Get the calibration map save data</p>
    <p>&nbsp;</p>
    <hr />
    <h3><a name="modifying-input-behaviors-during-runtime" id="modifying-input-behaviors-during-runtime"></a>Modifying Input Behaviors during runtime</h3>
    <p>Get the Input Behavior you wish to modify from the Player.</p>
    <p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ReInput_MappingHelper_GetInputBehaviors.htm">ReInput.mapping.GetInputBehaviors</a> - Gets a list of input behaviors from a specific player.<br />
    <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/Overload_Rewired_ReInput_MappingHelper_GetInputBehavior.htm">ReInput.mapping.GetInputBehavior</a> - Get a specific Input Behavior from a Player.</p>
    <p>Once you have the Input Behavior, modify any property you wish.</p>
    <p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_InputBehavior.htm">API Reference - InputBehavior</a></p>
    <p>You can save Input Behaviors to XML so your runtime changes can be loaded in another game session. The example mapping demo in Rewired/Examples/ControlRemapping1 includes saving and loading of Controller Maps, Axis Calibration Maps, and Input Behaviors. See the example for information on how to save and load Input Behaviors.</p>
    <p>&nbsp;</p>
<hr />
    <h3><a name="on-screen-touch-controllers" id="on-screen-touch-controllers"></a>Creating on-screen touch controllers</h3>
    <p>Touch controllers can be created with the help of <a href="CustomControllers.html">Custom Controllers</a>.</p>
    <p>Please see the touch controller example in Rewired/Examples/CustomControllers_Touch.</p>
    <p>In a future update, a ready-made drop-in touch controller may be included.</p>
    <p>&nbsp;</p>
    <hr />
    <h3><a name="new-controller-definitions" id="new-controller-definitions"></a>Creating new controller definitions</h3>
    <p><em>This is an advanced topic. Creating definitions requires a number of tools to help identify the elements and requires thorough testing on several platforms if you desire cross-platform compatibility. To make this process easier, if you have a joystick you want to support, please let me know via the support form on the website. I will do my best to get ahold of the controller and add definitions for it. If I cannot, you can arrange to mail the controller to me and I will add definitions for it and then mail it back to you.</em></p>
    <p><a href="https://www.youtube.com/watch?v=VkYVkRnjgjk" target="_blank">A video tutorial is available on YouTube here.</a></p>
    <p>You can create your own controller definitions if you want to support a specific controller without requiring the user manually map their controller elements. However there are several things you need to be aware of if you want to modify the list of supported controllers:</p>
    <ol>
      <li>You should copy the ControllerDataFiles object in Rewired/Internal/Data/Controllers to another location (preferably outside the Internal folder) and modify the copy. <em>NEVER modify the original ControllerDataFiles, otherwise when you upgrade Rewired, your ControllerDataFiles will be overwritten and your changes lost.</em></li>
      <li>You will need to link your Rewired Input Manager to the new ControllerDataFiles object. Click your Rewired Input Manager in the scene hierarchy and drag-and-drop your copy of ControllerDataFiles into the Data Files field in the inspector. This will instruct Rewired to use your modified ControllerDataFiles instead of the default original.</li>
      <li><em>NEVER modify any of the default Hardware Joystick Map or Hardware Joystick Template Map files.</em> If you do, the next time you upgrade Rewired, your changes will be overwritten. Instead, make a copy of any map you wish to modify, move it to another location (preferably outside the Internal folder), also copy the ControllerDataFiles object to another location, then link up the reference to the new Hardware Joystick Map or Hardware Joystick Template map in your ControllerDataFiles object.</li>
    </ol>
    <p><strong>Now that you know the rules, here are the steps to creating a new controller:</strong></p>
    <ol>
      <li>Copy ControllerDataFiles to a new location.</li>
      <li>Create a new HardwareJoystickMap object from the menu: Window -&gt; Rewired -&gt; Create -&gt; Assets -&gt; Hardware Joystick Map.</li>
      <li>Move the Hardware Joystick Map to a suitable location.</li>
      <li>Click your copy of ControllerDataFiles, then in the inspector, modify the Hardware Joystick Maps array to increase its size.</li>
      <li>Drag and drop your new Hardware Joystick Map into the new element in the array.</li>
      <li>Now, to edit your new Hardware Joystick Map, click its file and then click &quot;Launch Hardware Joystick Map Editor&quot; in the inspector.</li>
      
      <li>Edit the hardware joystick map. The process is as follows:
        <ul>
          <li>Create Element Identifiers for each of the controller's physical elements. An element can be designated as an Axis or a Button.</li>
          <li>Select a platform you wish to map such as Raw/Direct Input.</li>
          <li>On the Matching Criteria tab, fill out the information used to identify the controller. You can get this information by using the tool included for the platform you're editing. See Step 8 below.</li>
          <li>Create axes and buttons and map them to the platform's input sources. There are various options to help you deal with axes that behave in non-standard ways.</li>
          <li>Hats should be mapped to buttons, one for each of the four directions.</li>
        </ul>
      </li>
      <li>To identify the joystick elements on a particular platform, you may use the tools in the Rewired/DevTools folder. First, you must create a Rewired Input manager in the scene. Then drag the prefab for the appropriate platform prefab from Rewired/DevTools into the scene and press play to see a readout of joystick elements.  You may split the game window and edit your hardware map while the game is running so you can see the readout of the elements.</li>
      <li>Link your new ControllerDataFiles to your Input Manager in the scene so it will recognize the new joysticks.</li>
    </ol>
    <p><strong>The Hardware Joystick Map Editor window</strong></p>
<p><img src="files/images/hardwarejoystickmapeditor_settings.png" alt="Hardware Joystick Map Editor" /></p>
<hr />
    <h3><a name="new-controller-templates" id="new-controller-templates"></a>Creating new controller templates</h3>
<p><em>This is an advanced topic. Creating definitions requires a number of tools to help identify the elements and requires thorough testing on several platforms if you desire cross-platform compatibility. To make this process easier, if you have a joystick you want to support, please let me know via the support form on the website. I will do my best to get ahold of the controller and add definitions for it. If I cannot, you can arrange to mail the controller to me and I will add definitions for it and then mail it back to you.</em></p>
    <p>See <a href="#new-controller-definitions">Creating new controller definitions</a> for precautions on working with ControllerDataFiles and Hardware Joystick Maps as the same rules apply here.</p>
    <ol>
      <li>Create a new HardwareJoystickTemplateMap object from the menu: Window -&gt; Rewired -&gt; Create -&gt; Assets -&gt; Hardware Joystick Template Map.</li>
      <li>Move the Hardware Joystick Template Map to a suitable location.</li>
      <li>Click your copy of ControllerDataFiles, then in the inspector, modify the Joystick Templates array to increase its size.</li>
      <li>Drag and drop your new Hardware Joystick Template Map into the new element in the array.</li>
      <li>Now, to edit your new Hardware Joystick Template Map, click its file and then click &quot;Launch Hardware Joystick Template Map Editor&quot; in the inspector.</li>
      <li>Edit the hardware joystick template map by filling out the information. You will need to create a list of Element Identifiers for this template, add joysticks for each joystick the template supports, and create the maps for each joystick.</li>
    </ol>
    <p>&nbsp;</p>
<hr />
    <h3><a name="add-controller-to-existing-controller-template" id="new-controller-templates2"></a>Adding a controller to an existing controller template</h3>
    <p><em>This is an advanced topic. Creating definitions requires a number of tools to help identify the elements and requires thorough testing on several platforms if you desire cross-platform compatibility. To make this process easier, if you have a joystick you want to support, please let me know via the support form on the website. I will do my best to get ahold of the controller and add definitions for it. If I cannot, you can arrange to mail the controller to me and I will add definitions for it and then mail it back to you.</em></p>
    <p>See <a href="#new-controller-definitions">Creating new controller definitions</a> for precautions on working with ControllerDataFiles and Hardware Joystick Maps as the same rules apply here.</p>
    <p><a href="https://www.youtube.com/watch?v=VkYVkRnjgjk" target="_blank">A video tutorial is available on YouTube here.</a></p>
    <p>You can add a new controller definition to an existing template. Be sure the new controller has similar elements and a similar layout. The steps are as follows:</p>
    <ol>
      <li>First select the Hardware Joystick Map Template object from the Project view.</li>
      <li>Click the &quot;Launch Hardware Joystick Template Map Editor&quot; button in the inspector.</li>
      <li>In the window, select the &quot;Joysticks&quot; tab.</li>
      <li>Add a new joystick which will appear at the bottom of the list.</li>
      <li>Give this joystick a name. This is only used for identification purposes in this editor.</li>
      <li>You will need to get the GUID of the joystick you're adding from the Hardware Joystick Map file. Open the Hardware Joystick Map editor for the joystick you're adding, then copythe GUID from the &quot;Settings&quot; tab and paste it in the &quot;Joystick Guid&quot; field of the new joystick in the template editor.</li>
      <li>You will also need to get the Unity file GUID of the Hardware Joystick Map. This is different from the above GUID. You can obtain this file GUID enabling &quot;Visible Meta Files&quot; in Edit -&gt; Project Settings -&gt; Editor in the application menu, then navigating to the folder with the Hardware Joystick Map and opening the .meta file associated with the asset. The GUID should be clearly visible. Copy this GUID and paste it into the &quot;File Guid&quot; field of your new joystick in the template editor.</li>
      <li><strong>The above two steps will be streamlined in a future release by using drag-and-drop to assign the GUIDs.</strong></li>
      <li>On the &quot;Maps&quot; tab of the template editor, select your new joystick from the dropdown at the top.</li>
      <li>Click &quot;Add Entry&quot; to add a new element.</li>
      <li>You will be mapping each joystick element to a template element. The elements are listed by name.</li>
      <li>Add as many elements as there are Element Identifiers in your joystick.</li>
    </ol>
    <p>&nbsp;</p>
    <hr />
    <h3><a name="excluding-controller-definitions" id="excluding-controller-definitions"></a>Excluding controller definitions</h3>
    <p>See <a href="#new-controller-definitions">Creating new controller definitions</a> for precautions on working with ControllerDataFiles and Hardware Joystick Maps as the same rules apply here.</p>
    <p>If there is a particular controller that is included with Rewired that you don't want to support for some reason, you must do the following:</p>
  <ol>
    <li>Copy ControllerDataFiles to a new location.</li>
    <li>Click your copy of ControllerDataFiles, then in the inspector, remove the controller you don't want to support from the Hardware Joystick Maps array.</li>
    <li>Optionally collapse the array to remove any blank spaces.</li>
    <li>Link your new ControllerDataFiles to your Input Manager in the scene so it will recognize the new joystick list.</li>
  </ol>
  <hr />
  <h3><a name="identifying-joysticks-windows-fallback-or-webplayer" id="identifying-joysticks-windows-fallback-or-webplayer"></a>Identifying joysticks on Windows fallback or Windows Webplayer platforms</h3>
<p>Because of limitations of Unity's input system, you need to take special measures on these platforms for joysticks on Windows Standalone (only if you're <strong>not</strong> using native input -- Raw Input, Direct Input, or XInput -- native input does not have this problem) and Windows Webplayer (native input is not available in Webplayer). Note: This procedure is not required for OSX or other platforms.</p>

<p>Unity's input system has a major problem that makes it impossible to accurately identify which joystick id belongs to which physical joystick in Windows. To solve this issue, at game start and at any point a joystick is either connected or disconnected, you should ask the user to manually identify each joystick one-by-one by pressing a button on the joystick that matches the name displayed on-screen.</p>
<p>Update: Unity has finally announced a fix for this issue on Windows which is being rolled out in Unity 4.6.3p1, but will not be available in Unity 5.x until after the initial release. You can check if the current version of Unity includes the fix by checking the value of <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/P_Rewired_ReInput_unityJoystickIdentificationRequired.htm">ReInput.unityJoystickIdentificationRequired</a>. If true, you should allow your players to manually identify joysticks using the methods described below.</p>
<p>Rewired provides several functions to facilitate joystick identification:</p>
<p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ReInput_ControllerHelper_GetUnityJoystickIdFromAnyButtonOrAxisPress.htm">GetUnityJoystickIdFromAnyButtonOrAxisPress</a> - Returns the 0 based id of the Unity joystick whose button or axis was pressed. -1 if no button or axis was pressed on any joystick.            Use this to identify joysticks when using Unity's input system.            This has no effect if Unity Input is not handling input on the current platform. </p>
<p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ReInput_ControllerHelper_GetUnityJoystickIdFromAnyButtonPress.htm">GetUnityJoystickIdFromAnyButtonPress</a> - Returns the 0 based id of the Unity joystick whose button was pressed. -1 if no button was pressed on any joystick.            Use this to identify joysticks when using Unity's input system.            This has no effect if Unity Input is not handling input on the current platform. </p>
<p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ReInput_ControllerHelper_SetUnityJoystickIdFromAnyButtonOrAxisPress.htm">ReInput.controllers.SetUnityJoystickIdFromAnyButtonOrAxisPress</a> - Sets a Unity joystick as the input source of a Joystick.            The first Unity joystick that returns a button or axis press will be assigned to the Joystick.            While no buttons or axes are pressed, this will return False. When a press is detected, it will return True and assign the joystick id. </p>
<p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ReInput_ControllerHelper_SetUnityJoystickIdFromAnyButtonPress.htm">ReInput.controllers.SetUnityJoystickIdFromAnyButtonPress</a> - Sets a Unity joystick as the input source of a Joystick.            The first Unity joystick that returns a button press will be assigned to the Joystick.            While no buttons are pressed, this will return False. When a button press is detected, it will return True and assign the joystick id. </p>
<p><a href="http://guavaman.com/projects/rewired/docs/api-reference/html/M_Rewired_ReInput_ControllerHelper_SetUnityJoystickId.htm">ReInput.controllers.SetUnityJoystickId</a> - Sets a Unity joystick as the input source of a Joystick.            Use this to remap a joystick to its source when reconnected on platforms that use Unity Input.            This has no effect if Unity Input is not handling input on the current platform.</p>
<p>An example is included in Rewired/Examples/FallbackJoystickIdentification which you can look at to see how this is done.</p>
<p>The basic idea is this:</p>
<ol>
  <li>At game start, pop up a GUI asking the user to press a button on each named controller.</li>
  <li>When the user presses the button, set the joystick id on the joystick so Rewired can identify which joystick it is.</li>
  <li>Repeat the above steps for each joystick in the system.</li>
  <li>Any time a joystick is connected or disconnected, repeat the whole identification process for every joystick.</li>
</ol>
<p>Once the joysticks are properly identified, you can use Rewired as usual to receive input, remap controllers, etc. and everything will function properly.</p>
<p>Note: If the user has more than one joystick with identical names, there is no way to distinguish between the various controllers for identification. The order that the user identifies the controllers may change joystick to player assignments. There is nothing you can do to prevent this. If this happens, the user will have to reassign the controllers to players manually using a controller mapping screen. See <a href="#controller-mapping-screen">Creating a controller mapping screen</a> for more information.</p>
<p><strong>FallbackJoystickIdentificationDemo.cs from Rewired/Examples/FallbackJoystickIdentification</strong></p>
<pre class="code">
// This example shows how to have the user manually identify joysticks by name to assit with a Unity<br />// bug where joysticks cannot be associated with a Unity joystick ID without manual intervention when<br />// using Unity as the input source (as opposed to native input).

// NOTE: This only affects the Windows Standalone and Windows Webplayer platforms and was patched by Unity in 4.6.3p1,<br />// so this is no longer required in Unity 4.x versions after 4.6.3p1.<br />// Currently, Unity 5.x does not implement this fix yet, so this test is recommended.

using UnityEngine;
using System.Collections.Generic;
       <br />namespace Rewired.Demos {

    [AddComponentMenu("")]
    public class FallbackJoystickIdentificationDemo : MonoBehaviour {

        <span class="comment">// Consts</span>
        private const float windowWidth = 250.0f;
        private const float windowHeight = 250.0f;
        private const float inputDelay = 1.0f;

        <span class="comment">// Working  vars</span>
        private bool identifyRequired;
        private Queue<Joystick> joysticksToIdentify;
        private float nextInputAllowedTime;
        private GUIStyle style;

        private void Awake() {
            if(!ReInput.unityJoystickIdentificationRequired) return; <span class="comment">// this platform does not require manual joystick identificaion</span>

            <span class="comment">// Subscribe to device change events</span>
            ReInput.ControllerConnectedEvent += JoystickConnected;
            ReInput.ControllerDisconnectedEvent += JoystickDisconnected; <span class="comment">// this event is called after joystick is fully disconnected and removed from lists</span>

            IdentifyAllJoysticks();
        }

        private void JoystickConnected(ControllerStatusChangedEventArgs args) {
            <span class="comment">// Identify all joysticks on connect or disconnect because ids are not reliable in Unity</span>
            IdentifyAllJoysticks();
        }

        private void JoystickDisconnected(ControllerStatusChangedEventArgs args) {
            <span class="comment">// Identify all joysticks on connect or disconnect because ids are not reliable in Unity</span>
            IdentifyAllJoysticks();
        }

        public void IdentifyAllJoysticks() {
            <span class="comment">// Reset each time in case user changes joysticks while dialog is open</span>
            Reset();

            <span class="comment">// Check if there are any joysticks</span>
            if(ReInput.controllers.joystickCount == 0) return; <span class="comment">// no joysticks, nothing to do</span>

            <span class="comment">// Get current Joysticks</span>
            Joystick[] joysticks = ReInput.controllers.GetJoysticks();
            if(joysticks == null) return;

            <span class="comment">// Set flag to enable identification mode</span>
            identifyRequired = true;

            <span class="comment">// Create a queue out of the joysticks array</span>
            joysticksToIdentify = new Queue<Joystick>(joysticks);

            <span class="comment">// Set the time for accepting input again</span>
            SetInputDelay();
        }

        private void SetInputDelay() {
            <span class="comment">// Prevent user input for a period of time after each identification to handle button hold problem</span>
            nextInputAllowedTime = Time.time + inputDelay;
        }

        private void OnGUI() {
            if(!identifyRequired) return;
            if(joysticksToIdentify == null || joysticksToIdentify.Count == 0) {
                Reset();
                return;
            }

            <span class="comment">// Draw dialog window</span>
            Rect centerWindowRect = new Rect(Screen.width * 0.5f - windowWidth * 0.5f, Screen.height * 0.5f - windowHeight * 0.5f, windowWidth, windowHeight); <span class="comment">// create a cetered window rect</span>
            GUILayout.Window(0, centerWindowRect, DrawDialogWindow, "Joystick Identification Required"); <span class="comment">// draw the window</span>
            GUI.FocusWindow(0); <span class="comment">// focus the window</span>

            <span class="comment">// Do not allow input during input delay to filter out holding a button down and assigning all joysticks to a single joystick id</span>
            if(Time.time < nextInputAllowedTime) return;

            <span class="comment">// Poll for a joystick button press to identify the joystick</span>
            if(!ReInput.controllers.SetUnityJoystickIdFromAnyButtonPress(joysticksToIdentify.Peek().id)) {
                return; <span class="comment">// no input detected</span>
            }

            <span class="comment">// Remove the joystick from the queue now that we've used it</span>
            joysticksToIdentify.Dequeue();

            <span class="comment">// Renew the input delay time after press</span>
            SetInputDelay();

            <span class="comment">// Finish up if the queue is empty</span>
            if(joysticksToIdentify.Count == 0) {
                Reset(); <span class="comment">// done</span>
            }
        }

        private void DrawDialogWindow(int windowId) {
            if(!identifyRequired) return; <span class="comment">// window displays 1 frame after it is closed, so this is required to prevent null references below</span>

            <span class="comment">// Set up a temporary style with word wrap</span>
            if(style == null) {
                style = new GUIStyle(GUI.skin.label);
                style.wordWrap = true;
            }

            <span class="comment">// Draw the window contents</span>
            GUILayout.Space(15);
            GUILayout.Label("A joystick has been attached or removed. You will need to identify each joystick by pressing a button on the controller listed below:", style);
            Joystick joystick = joysticksToIdentify.Peek();
            GUILayout.Label("Press any button on \"" + joystick.name + "\" now.", style);

            GUILayout.FlexibleSpace();
            if(GUILayout.Button("Skip")) {
                joysticksToIdentify.Dequeue();
                return;
            }
        }

        private void Reset() {
            joysticksToIdentify = null;
            identifyRequired = false;
        }
    }
}</pre>
<hr />
  <h3><a name="hide-input-settings-launcher" id="hide-input-settings-launcher"></a>Hiding input settings on the Unity launcher</h3>
  <p>Unity's launcher has a built-in input tab that allows players to customize input through the Unity input manager settings. With Rewired, this interface is not only irrelevant, it is problematic. Rewired sets up over 400 input manager entries to be able to get input from all controllers on Unity fallback platforms. The user should not be allowed to make changes to these default inputs. However Unity gives you no option to hide this input manager settings tab in the launcher. There are three options to deal with this:</p>
  <ol>
    <li>Disable the launcher. This has the disadvantage of preventing the user from changing the display resolution. To disable it, see Display Resolution Dialog setting in the <a href="http://docs.unity3d.com/Manual/class-PlayerSettingsStandalone.html" target="_blank">Unity Player settings</a>.</li>

<li>Hack the launcher to hide the input tab. There are no clear guidelines on how to do this, but <a href="http://forum.unity3d.com/threads/remove-input-section-from-launcher.141438/#post-991442" target="_blank">this forum post </a>shows how one user did it on Windows.</li>
<li>Disable the launcher completely and implement your own custom launcher. This allows you to give your user resolution display options as well. (The Unity player can be launched with command line options which set the resolution. <a href="http://docs.unity3d.com/Manual/CommandLineArguments.html">See the section Unity Standalone Comand Line Arguments for more information</a>.)</li>
  </ol>
  <p>&nbsp;</p>
  <hr />
  <h3><a name="configuring-arcadeguns-g500" id="configuring-arcadeguns-g500"></a>Configuring ArcadeGuns G-500 AimTrak Light Guns</h3>
  <p>For the lightguns to work properly in Rewired, you must set the light gun mode to &quot;Joystick&quot; in the Arcade Guns Pro Utility. You should include this information in the documentation of your game so your users will know how the light guns should be configured.</p>
  <p>The button layout for the guns should be as follows:</p>
  <table width="100%" border="0">
    <tr>
      <td><strong>Element</strong></td>
      <td><strong>On-Screen</strong></td>
      <td><strong>Off-Screen</strong></td>
      </tr>
    <tr>
      <td>Trigger</td>
      <td>Button 3</td>
      <td>Button 4</td>
      </tr>
    <tr>
      <td>Small Button</td>
      <td>Button 1</td>
      <td>Button 5</td>
      </tr>
    <tr>
      <td>Large Button</td>
      <td>Button 2</td>
      <td>Button 6</td>
      </tr>
  </table>
  <p>&nbsp;</p>
  <hr />
  <h3><a name="Logitech-G27" id="Logitech-G27"></a>Logitech G27 Racing Wheel Support</h3>
  <p>On Windows, users must install the latest Logitech drivers for the G27 or the mappings in Rewired will be incorrect.</p>
  <p>In order to use force feedback on the Logitech G27, you must use the <a href="https://www.assetstore.unity3d.com/en/#!/content/6630" target="_new">Logitech Gaming SDK</a> which can be downloaded free from the Unity Asset Store. The SDK is only available for Windows.  </p>
  <p>While Rewired provides maps for <a href="SupportedControllers.html#Logitech-G27">several platforms</a> other than Windows, there is no official support of these platforms by Logitech, and therefore no force feedback SDK available. Additionally, the steering wheel may become somewhat rigid  because the centering spring may engage automatically on some platforms. Currently there is no recommended solution to these issues.</p>
  <p>&nbsp;</p>
  <hr />
  <h3><a name="Saitek-TPM" id="Logitech-G"></a>Saitek Pro Flight TPM Panel Support</h3>
  <p>Each time upon attaching the device to the system, you must push and pull each shaft fully through its complete range of motion. This will calibrate the device internally so that the axes report the correct values. This information should be included in your game manual so your players know how to use the device properly.</p>
  <p>&nbsp;</p>
  <hr />
  <h3><a name="dualshock-4-special-features" id="Logitech-G2"></a>Using Sony DualShock 4 special features</h3>
  <p>The Sony DualShock 4 supports vibration, gyro/accelerometer, touchpad, and changing the light color on Windows Standalone only at present (<a href="http://guavaman.com/projects/rewired/docs/RewiredEditor.html#Settings">Enhanced Device Support</a> option required.)</p>
  <p>The special features of this controller are accessible through the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_ControllerExtensions_DualShock4Extension.htm">Rewired.ControllerExtensions.DualShock4Extension</a> class.</p>
  <p>An example on how to use this class is shown below:</p>
<pre class="code">
using Rewired;
using Rewired.ControllerExtensions;

class DS4Test {

  <span class="comment">// Getting and setting various values on all DS4's assigned to this Player</span>
  public void TestDS4(Player player) {

<span class="comment">    // Loop through all Joysticks assigned to this Player</span>
    foreach(Joystick joystick in player.controllers.Joysticks) {

      <span class="comment">// Get the Dual Shock 4 Controller Extension from the Joystick</span>
      var ds4 = joystick.GetExtension&lt;Rewired.ControllerExtensions.DualShock4Extension&gt;();
      if(ds4 == null) continue; <span class="comment">// this is not a DS4, skip it</span>

      <span class="comment">// Get the raw accelerometer value</span>
      Vector3 accelerometer = ds4.GetAccelerometerValueRaw();

      <span class="comment">// Get the raw gyroscope value</span>
      Vector3 gyro = ds4.GetGyroscopeValueRaw();

      <span class="comment">// Get/Set vibration
      // Note: Vibration can also be set in a generic way through Joystick.SetVibration</span>
      float vibration = ds4.GetVibration(DualShock4MotorType.WeakMotor);
      ds4.SetVibration(DualShock4MotorType.StrongMotor, 1.0f); <span class="comment">// set vibration on a single motor by type</span>
      ds4.SetVibration(1.0f, 1.0f); <span class="comment">// set vibration on both motors simultaneously</span>
      ds4.StopVibration(); <span class="comment">// stop all vibration</span>

      <span class="comment">// Get the light color</span>
      Color lightColor = ds4.GetLightColor();

      <span class="comment">// Set the light color</span>
      ds4.SetLightColor(new Color(1.0f, 1.0f, 0.0f, 0.5f)); <span class="comment">// alpha is multiplied by rgb to get final value</span>
    
      <span class="comment">// Set the light flash</span>
      ds4.SetLightFlash(1.0f); // flash light every 1 second
      ds4.StopLightFlast(); // stop light flashing

      <span class="comment">// Get the battery level</span>
      float battery = ds4.batteryLevel;
    }
  }
}
</pre>
<p>&nbsp;</p>
<hr />
<h3><a name="raildriver-special-features" id="raildriver-special-features"></a>Using P.I. Engineering Rail Driver special features</h3>
<p>The P.I. Engineering RailDriver supports all features of the device (<a href="http://guavaman.com/projects/rewired/docs/RewiredEditor.html#Settings">Enhanced Device Support</a> option required.)</p>
<p>The special features of this controller are accessible through the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_ControllerExtensions_RailDriverExtension.htm">Rewired.ControllerExtensions.RailDriverExtension</a> class.</p>
<p>An example on how to use this class is shown below:</p>
<pre class="code">
using Rewired;
using Rewired.ControllerExtensions;

class RailDriverTest {

  <span class="comment">// Getting and setting various values on all RailDrivers assigned to this Player</span>
  public void TestRailDriver(Player player) {

<span class="comment">    // Loop through all Joysticks assigned to this Player</span>
    foreach(Joystick joystick in player.controllers.Joysticks) {

      <span class="comment">// Get the RailDriver Controller Extension from the Joystick</span>
      var rd = joystick.GetExtension&lt;Rewired.ControllerExtensions.RailDriverExtension&gt;();
      if(rd == null) continue; <span class="comment">// this is not a RailDriver, skip it</span>

      <span class="comment">// Enable/disable speaker</span>
      rd.speakerEnabled = true;

      <span class="comment">// Set LED display</span>
      int ledIndex = 0;
      byte ledDigitByte = 1; <span class="comment">// see RailDriver documentation for information on the digit byte</span>
      rd.SetLEDDisplay(0, ledDigitByte);
    }
  }
}</pre>
<p>&nbsp;</p>
<hr />
<h3><a name="xbox-one-controller-special-features" id="raildriver-special-features2"></a>Using XBox One controller special features on XBox One platform</h3>
<p>Special controller features of the XBox One gamepad such as vibration can be accessed via the <a href="http://guavaman.com/projects/rewired/docs/api-reference/html/T_Rewired_Platforms_XboxOne_XboxOneGamepadExtension.htm">XboxOneGamepadExtension</a> class available in the Joystick class as seen in the example below:
<pre class="code">
using Rewired;
using Rewired.Platforms.XboxOne;

class XBoxOneTest {

  void MyMethod() {

      <span class="comment">// Set vibration in all controllers in player</span>
      foreach(Joystick joystick in player.controllers.Joysticks) {

#if UNITY_XBOXONE &amp;&amp; !UNITY_EDITOR
          <span class="comment">// Get the ControllerExtension for Xbox One and set left gamepad motor to full value</span>
<span class="comment">          // Note: Vibration can also be set in a more generic way through Joystick.SetVibration by using the motor index.</span><br />          joystick.GetExtension&lt;XboxOneGamepadExtension&gt;().SetVibration(XboxOneGamepadMotorType.LeftMotor, 1.0f);
#else
          <span class="comment">// Set first motor to full value</span>
          joystick.SetVibration(0, 1.0f);
#endif<br />    }
  }
}</pre>&nbsp;</p>
<hr />
  <h3><a name="unity-ui" id="unity-ui"></a>Using Rewired to control Unity's new UI</h3>
<p><a href="RewiredStandaloneInputModule.html">See Rewired Standalone Input Module for information.</a></p>
  <p>&nbsp;</p>
<div class="bottom-pager clearfix">
  <a class="back-button" href="Documentation.html" title="Documentation"><span class="button-img"></span>Documentation</a>
</div>

<!-- InstanceEndEditable -->
        </div>
        
    </div>
  <div class="footer clearfix">
   	<p class="left">Copyright &copy;2014 <a href="http://guavaman.com" title="Guavaman Enterprises">Guavaman Enterprises</a>. All rights reserved. No materials may be reproduced without permission.</p>
  	<p class="right"><a href="http://guavaman.com/projects/rewired" title="Return to Rewired Website">Return to Rewired Website</a></p>
  </div>
  <!-- end .content --></div>
  <!-- end .container --></div>
</body>
<!-- InstanceEnd --></html>
